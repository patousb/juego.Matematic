<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math Challenge PRO</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Comic+Neue:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        :root {
            --azul: #4e8cff;
            --rojo: #ff6b6b;
            --verde: #6bff6b;
            --amarillo: #ffde59;
            --morado: #a459ff;
            --fondo: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            --texto: #333;
            --panel: white;
            --borde: #ddd;
            --sombra: rgba(0, 0, 0, 0.1);
            --tiempo-normal: #a459ff;
            --tiempo-alerta: #ff6b6b;
            --tiempo-restante: #ff6b6b; /* Nueva variable para el color del tiempo restante */
        }

        .dark-mode {
            --fondo: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            --texto: #f0f0f0;
            --panel: #1e2a3e;
            --borde: #333;
            --sombra: rgba(0, 0, 0, 0.3);
            --tiempo-normal: #a459ff;
            --tiempo-alerta: #ff6b6b;
            --tiempo-restante: #ff6b6b;
        }

        body {
            margin: 0;
            font-family: 'Comic Neue', cursive;
            background: var(--fondo);
            color: var(--texto);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden; /* Evita scroll innecesario */
            transition: background 0.5s ease;
        }

        .container {
            background: var(--panel);
            border-radius: 20px;
            box-shadow: var(--sombra) 0px 10px 30px;
            padding: 30px;
            text-align: center;
            max-width: 90%;
            width: 450px;
            position: relative;
            overflow: hidden; /* Para pantallas que se deslizan */
            transition: background 0.5s ease, box-shadow 0.5s ease;
            box-sizing: border-box;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 30px;
            box-sizing: border-box;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease-in-out;
            background: var(--panel); /* Asegura que la pantalla cubra la anterior */
            border-radius: 20px; /* Bordes redondeados también para las pantallas */
            z-index: 1; /* Por defecto, para que las pantallas activas lo tapen */
        }

        .screen.active {
            opacity: 1;
            pointer-events: auto;
            position: relative; /* Para que ocupe espacio y no se superponga constantemente */
            z-index: 2; /* Para que la pantalla activa siempre esté encima */
        }

        /* Loading Screen */
        .loading-icon {
            font-size: 5rem;
            color: var(--morado);
            animation: spin 2s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* General styles */
        h1 {
            font-family: 'Fredoka One', cursive;
            color: var(--azul);
            margin-bottom: 20px;
            font-size: 2.5rem;
            line-height: 1.2;
        }

        h2 {
            font-family: 'Fredoka One', cursive;
            color: var(--rojo);
            margin-bottom: 15px;
            font-size: 1.8rem;
        }

        p {
            font-size: 1.1rem;
            margin-bottom: 10px;
        }

        .input-group {
            margin-bottom: 20px;
            width: 100%;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            text-align: left;
            font-size: 1.1rem;
        }

        .input-group input,
        .input-group select {
            width: calc(100% - 20px);
            padding: 12px 10px;
            border: 2px solid var(--borde);
            border-radius: 10px;
            font-size: 1.1rem;
            color: var(--texto);
            background-color: var(--panel);
            transition: border-color 0.3s ease;
        }

        .input-group input:focus,
        .input-group select:focus {
            border-color: var(--azul);
            outline: none;
        }

        .btn {
            background: var(--morado);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 12px 25px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.1s ease;
            width: 100%;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:hover {
            background: var(--azul);
            transform: translateY(-2px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-green { background: var(--verde); }
        .btn-green:hover { background: #55d455; }
        .btn-red { background: var(--rojo); }
        .btn-red:hover { background: #d45555; }
        .btn-yellow { background: var(--amarillo); color: var(--texto); }
        .btn-yellow:hover { background: #e0c345; }

        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .progress-bar {
            width: 100%;
            height: 15px;
            background-color: var(--borde);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .progress {
            height: 100%;
            width: 0%;
            background-color: var(--verde);
            border-radius: 10px;
            transition: width 0.5s ease-in-out;
        }

        .question-area {
            background: var(--azul);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 20px;
            font-size: 2rem;
            font-family: 'Fredoka One', cursive;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 80px;
            box-shadow: var(--sombra) 0px 5px 15px;
        }

        .timer-container {
            position: relative;
            width: 100px;
            height: 100px;
            margin: 20px auto;
            border-radius: 50%;
        }

        .timer-circle {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: rotate(-90deg);
        }

        .timer-circle circle {
            fill: none;
            stroke: var(--tiempo-normal);
            stroke-width: 8px;
            stroke-dasharray: 283; /* 2 * PI * 45 (radius) */
            stroke-dashoffset: 0;
            transition: stroke-dashoffset 1s linear, stroke 0.5s ease;
        }

        .timer-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-family: 'Fredoka One', cursive;
            color: var(--tiempo-normal); /* Usar la variable de tiempo normal */
            transition: color 0.5s ease; /* Transición de color para el texto */
        }

        .keyboard {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .keyboard .key {
            background: var(--panel);
            border: 2px solid var(--borde);
            border-radius: 10px;
            padding: 15px 0;
            font-size: 1.8rem;
            font-family: 'Fredoka One', cursive;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.1s ease;
            box-shadow: var(--sombra) 0px 3px 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--texto);
        }

        .keyboard .key:hover {
            background: var(--borde);
            transform: translateY(-2px);
        }

        .keyboard .key:active {
            transform: translateY(0);
        }

        .keyboard .key.action {
            background: var(--amarillo);
            color: var(--texto);
        }
        .keyboard .key.action:hover { background: #e0c345; }
        .keyboard .key.action.red { background: var(--rojo); color: white; }
        .keyboard .key.action.red:hover { background: #d45555; }

        .answer-input {
            width: calc(100% - 20px);
            padding: 12px 10px;
            border: 2px solid var(--borde);
            border-radius: 10px;
            font-size: 1.5rem;
            text-align: center;
            margin-bottom: 15px;
            background-color: var(--panel);
            color: var(--texto);
            font-family: 'Fredoka One', cursive;
        }

        .answer-result {
            font-size: 1.5rem;
            font-weight: bold;
            margin-top: 10px;
            margin-bottom: 10px;
            min-height: 30px; /* Para evitar saltos de layout */
            color: var(--texto);
        }

        /* Animations for answer result */
        .tada {
            animation: tada 1s;
            color: var(--verde);
        }
        @keyframes tada {
            0% { transform: scale(1); }
            10%, 20% { transform: scale(0.9) rotate(-3deg); }
            30%, 50%, 70%, 90% { transform: scale(1.1) rotate(3deg); }
            40%, 60%, 80% { transform: scale(1.1) rotate(-3deg); }
            100% { transform: scale(1) rotate(0); }
        }

        .shake {
            animation: shake 0.82s cubic-bezier(.36,.07,.19,.97) both;
            transform: translate3d(0, 0, 0);
            backface-visibility: hidden;
            perspective: 1000px;
            color: var(--rojo);
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        /* Multiplayer Lobby */
        .lobby-info {
            margin-bottom: 20px;
        }
        .lobby-info p {
            font-size: 1.2rem;
        }
        .lobby-info span {
            font-family: 'Fredoka One', cursive;
            color: var(--azul);
            font-size: 1.5rem;
        }

        .player-list {
            list-style: none;
            padding: 0;
            margin-bottom: 20px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--borde);
            border-radius: 10px;
            background: var(--panel);
        }

        .player-list li {
            display: flex;
            align-items: center;
            padding: 10px;
            border-bottom: 1px dashed var(--borde);
        }

        .player-list li:last-child {
            border-bottom: none;
        }

        .player-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid var(--verde);
            object-fit: cover;
        }

        .player-name {
            font-weight: bold;
            flex-grow: 1;
        }

        .player-score {
            font-weight: bold;
            color: var(--morado);
        }

        .mode-voting-area {
            margin-top: 20px;
            margin-bottom: 20px;
        }

        .mode-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .mode-item {
            background: var(--borde);
            border-radius: 10px;
            padding: 10px;
            cursor: pointer;
            transition: background 0.3s ease, transform 0.1s ease;
            font-weight: bold;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .mode-item:hover {
            background: var(--azul);
            color: white;
            transform: translateY(-2px);
        }

        .mode-item.selected {
            background: var(--verde);
            color: white;
            box-shadow: var(--sombra) 0px 5px 10px;
            border: 2px solid var(--verde);
        }

        .mode-item.selected:hover {
            background: var(--verde); /* No cambia color al hover si ya está seleccionado */
        }

        .mode-vote-count {
            position: absolute;
            top: 5px;
            right: 5px;
            background: var(--rojo);
            color: white;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.8rem;
            font-family: 'Fredoka One', cursive;
        }

        /* Final Results */
        .final-ranking-list {
            list-style: none;
            padding: 0;
            margin-top: 20px;
            max-height: 250px;
            overflow-y: auto;
            border: 1px solid var(--borde);
            border-radius: 10px;
            background: var(--panel);
        }

        .final-ranking-list li {
            display: flex;
            align-items: center;
            padding: 10px;
            border-bottom: 1px dashed var(--borde);
            font-size: 1.1rem;
            color: var(--texto);
        }

        .final-ranking-list li:last-child {
            border-bottom: none;
        }

        .final-ranking-list .ranking-avatar {
            width: 35px;
            height: 35px;
            margin-right: 10px;
            border-color: var(--morado);
        }

        .final-ranking-list .ranking-name {
            flex-grow: 1;
            font-weight: bold;
        }

        .final-ranking-list .ranking-score {
            font-family: 'Fredoka One', cursive;
            color: var(--azul);
            font-size: 1.3rem;
        }

        /* Utilities */
        .hidden {
            display: none !important;
        }

        .avatar-selection {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        .avatar-selection img {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: border-color 0.2s ease, transform 0.1s ease;
        }

        .avatar-selection img:hover {
            transform: scale(1.05);
        }

        .avatar-selection img.selected {
            border-color: var(--verde);
            box-shadow: 0 0 0 4px var(--verde);
        }

        .controls-bottom {
            margin-top: 20px;
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }
        .controls-bottom .btn {
            width: auto; /* Anula el width: 100% */
            flex-grow: 1; /* Permite que los botones ocupen el espacio disponible */
            margin-bottom: 0; /* Elimina el margin-bottom para que se distribuyan horizontalmente */
        }

        /* Notifications */
        .notification-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .notification {
            background-color: var(--panel);
            color: var(--texto);
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: var(--sombra) 0 5px 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            max-width: 300px;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }
        .notification.hide {
            opacity: 0;
            transform: translateX(100%);
        }
        .notification-icon {
            font-size: 1.5rem;
        }
        .notification.success .notification-icon { color: var(--verde); }
        .notification.error .notification-icon { color: var(--rojo); }
        .notification.info .notification-icon { color: var(--azul); }

        /* Settings/Controls */
        .settings-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 10px;
            z-index: 10; /* Para que estén por encima de las pantallas inactivas */
        }
        .setting-btn {
            background: var(--borde);
            color: var(--texto);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            cursor: pointer;
            transition: background 0.3s ease;
        }
        .setting-btn:hover {
            background: var(--sombra);
        }
        .setting-btn.active {
            background: var(--morado);
            color: white;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="notification-container"></div>

        <div class="settings-controls">
            <button id="toggleSoundBtn" class="setting-btn">
                <i class="fas fa-volume-up"></i>
            </button>
            <button id="toggleDarkModeBtn" class="setting-btn">
                <i class="fas fa-moon"></i>
            </button>
        </div>

        <div id="loadingScreen" class="screen active">
            <i class="fas fa-spinner loading-icon"></i>
            <p>Cargando...</p>
        </div>

        <div id="joinScreen" class="screen">
            <h1>Math Challenge PRO</h1>
            <div class="avatar-selection">
                <img src="https://api.dicebear.com/7.x/pixel-art/svg?seed=avatar1" alt="Avatar 1" data-avatar="avatar1">
                <img src="https://api.dicebear.com/7.x/pixel-art/svg?seed=avatar2" alt="Avatar 2" data-avatar="avatar2">
                <img src="https://api.dicebear.com/7.x/pixel-art/svg?seed=avatar3" alt="Avatar 3" data-avatar="avatar3">
                <img src="https://api.dicebear.com/7.x/pixel-art/svg?seed=avatar4" alt="Avatar 4" data-avatar="avatar4">
                <img src="https://api.dicebear.com/7.x/pixel-art/svg?seed=avatar5" alt="Avatar 5" data-avatar="avatar5">
            </div>
            <div class="input-group">
                <label for="playerName">Tu Nombre:</label>
                <input type="text" id="playerName" placeholder="Ej: SuperMath" maxlength="15">
            </div>
            <div class="input-group">
                <label for="grade">Grado/Nivel:</label>
                <select id="grade">
                    <option value="basic">Básico (1-3)</option>
                    <option value="intermediate">Intermedio (4-6)</option>
                    <option value="advanced">Avanzado (7-9)</option>
                    <option value="expert">Experto (10-11+)</option>
                </select>
            </div>
            <button id="createGameBtn" class="btn btn-green"><i class="fas fa-plus-circle"></i> Crear Sala</button>
            <div class="input-group">
                <label for="gamePin">PIN de la Sala:</label>
                <input type="text" id="gamePin" placeholder="XXXXXX" maxlength="6">
            </div>
            <button id="joinGameBtn" class="btn btn-azul"><i class="fas fa-users"></i> Unirse a Sala</button>
        </div>

        <div id="multiplayerLobby" class="screen">
            <h2>Sala: <span id="gamePinDisplay"></span></h2>
            <div class="lobby-info">
                <p>Jugadores en la sala:</p>
                <ul id="otherPlayersList" class="player-list">
                    </ul>
            </div>

            <div class="mode-voting-area">
                <h3>Vota por el modo de juego:</h3>
                <div class="mode-grid">
                    <div class="mode-item" data-mode="Operación Rápida">
                        Operación Rápida <span class="mode-vote-count">0</span>
                    </div>
                    <div class="mode-item" data-mode="Número Misterioso">
                        Número Misterioso <span class="mode-vote-count">0</span>
                    </div>
                    <div class="mode-item" data-mode="Secuencia Numérica">
                        Secuencia Numérica <span class="mode-vote-count">0</span>
                    </div>
                    <div class="mode-item" data-mode="Potenciación">
                        Potenciación <span class="mode-vote-count">0</span>
                    </div>
                    <div class="mode-item" data-mode="Operaciones Combinadas">
                        Operaciones Combinadas <span class="mode-vote-count">0</span>
                    </div>
                    <div class="mode-item" data-mode="Verdadero/Falso">
                        Verdadero/Falso <span class="mode-vote-count">0</span>
                    </div>
                    <div class="mode-item" data-mode="El más cercano gana">
                        El más cercano gana <span class="mode-vote-count">0</span>
                    </div>
                </div>
            </div>

            <div class="lobby-controls">
                <button id="startGameBtn" class="btn btn-green" style="display: none;">
                    <i class="fas fa-play"></i> Iniciar Partida
                </button>
                <button id="backToLobbyBtn" class="btn btn-red"><i class="fas fa-arrow-left"></i> Volver al Lobby</button>
            </div>
        </div>

        <div id="gameContainer" class="screen">
            <div class="game-header">
                <span id="playerScoreDisplay">Puntos: 0</span>
                <div class="timer-container">
                    <svg class="timer-circle" viewBox="0 0 100 100">
                        <circle cx="50" cy="50" r="45"></circle>
                    </svg>
                    <span id="timerText" class="timer-text">30</span>
                </div>
                <span id="questionCountDisplay">Pregunta: 1/10</span>
            </div>
            <div class="progress-bar">
                <div id="progressBar" class="progress"></div>
            </div>
            <div id="currentQuestion" class="question-area">¿Cuál es la respuesta?</div>
            <input type="text" id="playerAnswer" class="answer-input" readonly placeholder="0">
            <div id="answerResult" class="answer-result"></div>

            <div class="keyboard">
                <div class="key" data-number="1">1</div>
                <div class="key" data-number="2">2</div>
                <div class="key" data-number="3">3</div>
                <div class="key" data-number="4">4</div>
                <div class="key" data-number="5">5</div>
                <div class="key" data-number="6">6</div>
                <div class="key" data-number="7">7</div>
                <div class="key" data-number="8">8</div>
                <div class="key" data-number="9">9</div>
                <div class="key action" data-action="clear"><i class="fas fa-backspace"></i></div>
                <div class="key" data-number="0">0</div>
                <div class="key action" data-action="negative">+/-</div>
            </div>
            <button id="submitAnswerBtn" class="btn btn-verde">
                <i class="fas fa-check-circle"></i> Responder
            </button>

            <h3>Ranking en vivo:</h3>
            <ul id="rankingList" class="player-list">
                </ul>
        </div>

        <div id="finalResults" class="screen">
            <h2>Resultados Finales</h2>
            <ul id="finalRankingList" class="final-ranking-list">
                </ul>
            <button id="restartGameBtn" class="btn btn-azul"><i class="fas fa-redo"></i> Jugar de Nuevo</button>
            <button id="returnToLobbyFromResultsBtn" class="btn btn-red"><i class="fas fa-arrow-left"></i> Volver al Lobby</button>
        </div>
    </div>

    <audio id="clickSound" src="https://www.soundjay.com/buttons/button-click-01.mp3" preload="auto"></audio>
    <audio id="correctSound" src="https://www.soundjay.com/misc/winning-sound-2.mp3" preload="auto"></audio>
    <audio id="incorrectSound" src="https://www.soundjay.com/misc/fail-buzzer-01.mp3" preload="auto"></audio>
    <audio id="gameOverSound" src="https://www.soundjay.com/misc/game-over-arcade.mp3" preload="auto"></audio>

    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <script>
        class GameManager {
            constructor() {
                this.socket = io('http://localhost:3000'); // Asegúrate de que esta URL coincida con tu backend
                this.player = {
                    id: this.generateId(),
                    name: '',
                    avatar: '',
                    grade: '',
                    score: 0,
                    isHost: false, // MODIFICADO: Ahora es una propiedad del jugador
                    votedForMode: null // NUEVO: Para saber qué votó el jugador
                };
                this.gamePin = '';
                this.isHost = false; // MODIFICADO: Propiedad para el GameManager
                this.soundEnabled = true;
                this.currentTimerValue = 30; // Tiempo inicial del temporizador
                this.timerInterval = null;
                this.gameStarted = false; // NUEVO: Bandera para controlar si el juego está en curso
                this.currentQuestion = null; // La pregunta actual del servidor
                this.playerScore = 0; // Puntuación local del jugador
                this.questionCount = 0; // Para el progreso de preguntas
                this.totalQuestions = 10; // Total de preguntas (debería venir del servidor)

                // Referencias a elementos del DOM
                this.loadingScreen = document.getElementById('loadingScreen');
                this.joinScreen = document.getElementById('joinScreen');
                this.multiplayerLobby = document.getElementById('multiplayerLobby');
                this.gameContainer = document.getElementById('gameContainer');
                this.finalResults = document.getElementById('finalResults');

                this.playerNameInput = document.getElementById('playerName');
                this.gradeSelect = document.getElementById('grade');
                this.gamePinInput = document.getElementById('gamePin');
                this.createGameBtn = document.getElementById('createGameBtn');
                this.joinGameBtn = document.getElementById('joinGameBtn');
                this.startGameBtn = document.getElementById('startGameBtn'); // NUEVO: Referencia al botón de iniciar
                this.submitAnswerBtn = document.getElementById('submitAnswerBtn');
                this.backToLobbyBtn = document.getElementById('backToLobbyBtn');
                this.restartGameBtn = document.getElementById('restartGameBtn');
                this.returnToLobbyFromResultsBtn = document.getElementById('returnToLobbyFromResultsBtn'); // NUEVO: Botón volver al lobby de resultados
                this.toggleSoundBtn = document.getElementById('toggleSoundBtn');
                this.toggleDarkModeBtn = document.getElementById('toggleDarkModeBtn');

                this.playerAnswerInput = document.getElementById('playerAnswer');
                this.currentQuestionDisplay = document.getElementById('currentQuestion');
                this.answerResultDisplay = document.getElementById('answerResult');
                this.timerText = document.getElementById('timerText');
                this.timerCircle = document.querySelector('.timer-circle circle');
                this.progressBar = document.getElementById('progressBar');
                this.playerScoreDisplay = document.getElementById('playerScoreDisplay');
                this.questionCountDisplay = document.getElementById('questionCountDisplay');
                this.rankingList = document.getElementById('rankingList');
                this.otherPlayersList = document.getElementById('otherPlayersList');
                this.finalRankingList = document.getElementById('finalRankingList');
                this.notificationContainer = document.querySelector('.notification-container'); // Referencia al contenedor de notificaciones

                this.avatarSelectionImgs = document.querySelectorAll('.avatar-selection img');
                this.modeItems = document.querySelectorAll('.mode-item'); // Referencia a los elementos de modo de juego

                // NUEVO: Propiedad para almacenar los votos de los modos (cliente)
                this.modeVotes = {
                    'Operación Rápida': 0,
                    'Número Misterioso': 0,
                    'Secuencia Numérica': 0,
                    'Potenciación': 0,
                    'Operaciones Combinadas': 0,
                    'Verdadero/Falso': 0,
                    'El más cercano gana': 0,
                };
            }

            initGame() {
                // Inicializar Socket.IO y listeners globales
                this.socket.on('connect', () => {
                    console.log('Conectado al servidor Socket.IO');
                    this.showScreen('joinScreen'); // Muestra la pantalla de unirse una vez conectado
                });

                this.socket.on('disconnect', (reason) => {
                    console.warn('Desconectado del servidor:', reason);
                    this.handleNetworkError(reason, '¡Desconectado del juego!');
                    this.showScreen('loadingScreen'); // Vuelve a la pantalla de carga o unirse
                });

                this.socket.on('connect_error', (error) => {
                    console.error('Error de conexión a Socket.IO:', error);
                    this.handleNetworkError(error, 'Error al conectar al servidor');
                    this.showScreen('loadingScreen'); // Vuelve a la pantalla de carga
                });

                this.setupEventListeners();
                this.loadSettings(); // Cargar la configuración de sonido/tema
            }

            setupEventListeners() {
                // Selección de Avatar
                this.avatarSelectionImgs.forEach(img => {
                    img.addEventListener('click', () => {
                        this.avatarSelectionImgs.forEach(i => i.classList.remove('selected'));
                        img.classList.add('selected');
                        this.player.avatar = img.dataset.avatar;
                        this.playSound('clickSound');
                    });
                });

                // Botones de Crear/Unirse
                this.createGameBtn.addEventListener('click', () => {
                    this.playSound('clickSound');
                    if (!this.player.avatar) {
                        this.showNotification('Por favor, selecciona un avatar.', 'error');
                        return;
                    }
                    if (!this.playerNameInput.value.trim()) {
                        this.showNotification('Por favor, ingresa tu nombre.', 'error');
                        return;
                    }

                    this.player.name = this.playerNameInput.value.trim();
                    this.player.grade = this.gradeSelect.value;
                    this.socket.emit('createGame', { player: this.player });
                });

                this.joinGameBtn.addEventListener('click', () => {
                    this.playSound('clickSound');
                    if (!this.player.avatar) {
                        this.showNotification('Por favor, selecciona un avatar.', 'error');
                        return;
                    }
                    if (!this.playerNameInput.value.trim()) {
                        this.showNotification('Por favor, ingresa tu nombre.', 'error');
                        return;
                    }
                    const pin = this.gamePinInput.value.trim();
                    if (!pin) {
                        this.showNotification('Por favor, ingresa el PIN de la sala.', 'error');
                        return;
                    }

                    this.player.name = this.playerNameInput.value.trim();
                    this.player.grade = this.gradeSelect.value;
                    this.socket.emit('joinGame', { pin: pin, player: this.player });
                });

                // Teclado virtual
                const keyboard = document.querySelector('.keyboard');
                if (keyboard) {
                    keyboard.addEventListener('click', (event) => {
                        const key = event.target.closest('.key');
                        if (!key || this.playerAnswerInput.disabled) return; // No hacer nada si el input está deshabilitado

                        this.playSound('clickSound');
                        const number = key.dataset.number;
                        const action = key.dataset.action;

                        if (number !== undefined) {
                            // Limitar la longitud de la respuesta si es necesario
                            if (this.playerAnswerInput.value.length < 10) {
                                this.playerAnswerInput.value += number;
                            }
                        } else if (action === 'clear') {
                            this.playerAnswerInput.value = this.playerAnswerInput.value.slice(0, -1);
                        } else if (action === 'negative') {
                            if (this.playerAnswerInput.value.startsWith('-')) {
                                this.playerAnswerInput.value = this.playerAnswerInput.value.substring(1);
                            } else if (this.playerAnswerInput.value !== '') {
                                this.playerAnswerInput.value = '-' + this.playerAnswerInput.value;
                            }
                        }
                    });
                }

                // Botón Responder
                this.submitAnswerBtn.addEventListener('click', () => {
                    this.playSound('clickSound');
                    const respuesta = this.playerAnswerInput.value;
                    if (respuesta.trim() === '') {
                        this.showNotification('Por favor, ingresa una respuesta.', 'error');
                        return;
                    }
                    this.checkAnswer(respuesta); // MODIFICADO: Ahora solo envía al servidor
                });

                // NUEVO: Botón "Iniciar Partida" (solo para el host)
                if (this.startGameBtn) {
                    this.startGameBtn.addEventListener('click', () => {
                        if (this.isHost) {
                            this.playSound('clickSound');
                            this.showNotification('Iniciando partida...', 'info');
                            this.socket.emit('host:startGame', { gamePin: this.gamePin }); // El host le dice al servidor que inicie
                        }
                    });
                }

                // Botón Volver al Lobby (desde el juego)
                this.backToLobbyBtn.addEventListener('click', () => {
                    this.playSound('clickSound');
                    this.showScreen('multiplayerLobby');
                    // MODIFICADO: Reiniciar estado del lobby al volver
                    this.resetLobbyState();
                    this.socket.emit('player:backToLobby', { gamePin: this.gamePin, playerId: this.player.id }); // Notificar al servidor
                });

                // NUEVO: Botón Volver al Lobby (desde resultados finales)
                this.returnToLobbyFromResultsBtn.addEventListener('click', () => {
                    this.playSound('clickSound');
                    this.showScreen('multiplayerLobby');
                    this.resetLobbyState(); // ¡NUEVO! Llama a resetear el estado del lobby
                    this.socket.emit('player:backToLobby', { gamePin: this.gamePin, playerId: this.player.id }); // Notifica al servidor
                });

                // Botón Jugar de Nuevo (desde resultados finales) - Esto probablemente reinicia la sala o crea una nueva
                this.restartGameBtn.addEventListener('click', () => {
                    this.playSound('clickSound');
                    this.showNotification('Preparando nueva partida...', 'info');
                    this.socket.emit('game:restart', { gamePin: this.gamePin, playerId: this.player.id });
                    // El servidor debería manejar el reinicio de la sala y volver al lobby
                });

                // Botones de Configuración
                this.toggleSoundBtn.addEventListener('click', () => {
                    this.soundEnabled = !this.soundEnabled;
                    this.toggleSoundBtn.classList.toggle('active', this.soundEnabled);
                    this.toggleSoundBtn.querySelector('i').className = this.soundEnabled ? 'fas fa-volume-up' : 'fas fa-volume-mute';
                    localStorage.setItem('soundEnabled', this.soundEnabled);
                    this.playSound('clickSound'); // Reproducir sonido si se acaba de activar
                });

                this.toggleDarkModeBtn.addEventListener('click', () => {
                    document.body.classList.toggle('dark-mode');
                    const isDarkMode = document.body.classList.contains('dark-mode');
                    this.toggleDarkModeBtn.classList.toggle('active', isDarkMode);
                    this.toggleDarkModeBtn.querySelector('i').className = isDarkMode ? 'fas fa-sun' : 'fas fa-moon';
                    localStorage.setItem('darkModeEnabled', isDarkMode);
                    this.playSound('clickSound');
                });

                // --- Socket.IO Event Listeners ---
                this.socket.on('roomCreated', (data) => {
                    this.gamePin = data.pin;
                    this.isHost = true; // Eres el host
                    this.player.isHost = true; // Asegúrate de que el objeto player también refleje esto
                    document.getElementById('gamePinDisplay').textContent = this.gamePin;
                    this.showScreen('multiplayerLobby');
                    this.showNotification(`Sala creada. PIN: ${this.gamePin}`, 'success');
                    this.startGameBtn.style.display = 'block'; // Mostrar botón de iniciar partida al host
                    this.updateLobbyPlayers(data.players); // Actualizar lista de jugadores
                });

                this.socket.on('roomJoined', (data) => {
                    this.gamePin = data.pin;
                    this.isHost = false; // No eres el host
                    this.player.isHost = false; // Asegúrate de que el objeto player también refleje esto
                    document.getElementById('gamePinDisplay').textContent = this.gamePin;
                    this.showScreen('multiplayerLobby');
                    this.showNotification(`Te uniste a la sala ${this.gamePin}`, 'info');
                    this.startGameBtn.style.display = 'none'; // Asegurarse de que no vea el botón de iniciar
                    this.updateLobbyPlayers(data.players); // Actualizar lista de jugadores
                });

                this.socket.on('playerJoined', (data) => {
                    this.showNotification(`${data.player.name} se unió a la sala.`, 'info');
                    this.updateLobbyPlayers(data.players); // Lista actualizada de todos los jugadores
                });

                this.socket.on('playerLeft', (data) => {
                    this.showNotification(`${data.playerName} salió de la sala.`, 'info');
                    this.updateLobbyPlayers(data.players); // Lista actualizada de todos los jugadores
                });

                // MODIFICADO: 'gameStarted' ahora es disparado por el servidor después de que el host presione "Iniciar Partida"
                this.socket.on('gameStarted', (data) => {
                    this.gameStarted = true;
                    this.currentQuestion = data.questionData; // El servidor envía la primera pregunta
                    this.totalQuestions = data.totalQuestions || 10; // MODIFICADO: Recibir total de preguntas del servidor
                    this.questionCount = 0; // Se actualiza al recibir la primera pregunta
                    this.playerScore = 0; // Reiniciar puntuación al inicio del juego
                    this.playerScoreDisplay.textContent = `Puntos: ${this.playerScore}`;
                    this.updateProgressBar(); // Asegurar que la barra de progreso esté en 0
                    this.displayQuestion(data.questionData);
                    this.currentTimerValue = data.initialTime; // Sincroniza el tiempo inicial
                    this.startTimer(); // Ahora sí, inicia el temporizador
                    this.showScreen('gameContainer');
                    this.showNotification('¡La partida ha comenzado!', 'success');
                    // Habilitar inputs/botones
                    this.playerAnswerInput.disabled = false;
                    this.submitAnswerBtn.disabled = false;
                    this.playerAnswerInput.value = ''; // Limpiar cualquier respuesta anterior
                    this.answerResultDisplay.textContent = ''; // Limpiar mensaje de resultado
                    this.rankingList.innerHTML = ''; // Limpiar ranking en vivo al inicio
                });

                // Nueva pregunta del servidor
                this.socket.on('newQuestion', (data) => {
                    this.currentQuestion = data.questionData;
                    this.currentTimerValue = data.newTimer || 30; // Sincroniza el temporizador para la nueva pregunta
                    this.questionCount++; // Incrementa el contador de preguntas
                    this.displayQuestion(data.questionData);
                    this.playerAnswerInput.value = ''; // Limpiar respuesta anterior
                    this.answerResultDisplay.textContent = ''; // Limpiar mensaje de resultado
                    this.playerAnswerInput.disabled = false; // Habilitar input
                    this.submitAnswerBtn.disabled = false; // Habilitar botón
                    this.updateProgressBar(); // Actualizar barra de progreso
                    this.startTimer(); // Iniciar temporizador para la nueva pregunta
                });

                // Resultado de la pregunta
                this.socket.on('questionResult', (data) => {
                    if (data.isCorrect) {
                        this.displayResult('¡Correcto!', true);
                        this.playSound('correctSound');
                        // La puntuación se actualiza en el servidor, solo la recibimos en rankingUpdate
                    } else {
                        this.displayResult(`Incorrecto. La respuesta era: ${data.correctAnswer}`, false);
                        this.playSound('incorrectSound');
                    }
                    this.playerScore = data.playerScore || this.playerScore; // Actualiza la puntuación local
                    this.playerScoreDisplay.textContent = `Puntos: ${this.playerScore}`;
                    this.stopTimer(); // MODIFICADO: Detener el temporizador después de la respuesta
                });

                // Actualización del ranking en vivo
                this.socket.on('game:rankingUpdate', (data) => {
                    this.updateLiveRanking(data.players); // Los jugadores ya vienen ordenados por score
                });

                // Juego terminado
                this.socket.on('gameEnded', (data) => {
                    this.gameStarted = false;
                    this.stopTimer();
                    this.playSound('gameOverSound');
                    this.showScreen('finalResults');
                    this.displayFinalResults(data.finalRanking);
                    this.showNotification('¡Juego Terminado!', 'info');
                });

                // Actualización de votos (clientes)
                this.socket.on('voteUpdate', (data) => {
                    // console.log('Votos actualizados recibidos:', data.modeVotes);
                    this.modeVotes = data.modeVotes; // Sincroniza con los votos del servidor
                    this.updateModeVoteCounts();
                    this.updatePlayerVotesInLobby(data.players); // Actualizar qué votó cada jugador
                });

                // NUEVO: Evento para resetear votos (disparado por el servidor al volver al lobby o iniciar nueva ronda)
                this.socket.on('lobby:resetVotes', () => {
                    this.resetLobbyState();
                });

                // Notificaciones generales
                this.socket.on('notification', (data) => {
                    this.showNotification(data.message, data.type);
                });

                // --- Voting Logic ---
                this.modeItems.forEach(item => {
                    item.addEventListener('click', () => {
                        if (this.player.votedForMode === item.dataset.mode) {
                            // Si ya votó por este modo, deseleccionar
                            this.player.votedForMode = null;
                            item.classList.remove('selected');
                            this.socket.emit('player:vote', { gamePin: this.gamePin, playerId: this.player.id, mode: null });
                        } else {
                            // Si vota por un nuevo modo
                            this.modeItems.forEach(i => i.classList.remove('selected'));
                            item.classList.add('selected');
                            this.player.votedForMode = item.dataset.mode;
                            this.socket.emit('player:vote', { gamePin: this.gamePin, playerId: this.player.id, mode: item.dataset.mode });
                        }
                        this.playSound('clickSound');
                    });
                });
            }

            // --- Gestión de Pantallas ---
            showScreen(screenId) {
                const screens = document.querySelectorAll('.screen');
                screens.forEach(screen => {
                    screen.classList.remove('active');
                    screen.style.zIndex = 1; // Restaura z-index por defecto
                });
                const targetScreen = document.getElementById(screenId);
                if (targetScreen) {
                    targetScreen.classList.add('active');
                    targetScreen.style.zIndex = 2; // Asegura que la pantalla activa esté encima
                }
            }

            hideScreen(screenId) {
                const targetScreen = document.getElementById(screenId);
                if (targetScreen) {
                    targetScreen.classList.remove('active');
                    targetScreen.style.zIndex = 1;
                }
            }

            // --- Lógica del Juego ---
            updateTimer() {
                if (!this.gameStarted) return; // NUEVO: El temporizador solo se actualiza si el juego ha iniciado

                // MODIFICADO: Asegurarse de que el timerText y timerCircle estén actualizados
                if (this.currentTimerValue > 0) {
                    this.currentTimerValue--;
                    this.timerText.textContent = this.currentTimerValue;

                    // Actualizar el círculo del temporizador (SVG)
                    const circumference = 2 * Math.PI * 45; // Radio 45, asumiendo un círculo de radio 45
                    const progress = this.currentTimerValue / 30; // Assuming initial time is 30
                    const offset = circumference * (1 - progress);
                    this.timerCircle.style.strokeDashoffset = offset;

                    // Cambiar color a rojo si quedan pocos segundos
                    if (this.currentTimerValue <= 5) {
                        this.timerCircle.style.stroke = 'var(--tiempo-alerta)';
                        this.timerText.style.color = 'var(--tiempo-alerta)';
                    } else {
                        this.timerCircle.style.stroke = 'var(--tiempo-normal)';
                        this.timerText.style.color = 'var(--tiempo-normal)';
                    }

                } else {
                    // ¡El tiempo ha terminado para esta pregunta!
                    this.stopTimer(); // Detener el temporizador visual
                    this.showNotification('¡Tiempo agotado!', 'error');
                    this.playSound('incorrectSound'); // O un sonido de tiempo agotado

                    // Deshabilitar la entrada y el botón de respuesta
                    this.playerAnswerInput.disabled = true;
                    this.submitAnswerBtn.disabled = true;

                    // **CRÍTICO: Notificar al servidor que el tiempo ha expirado**
                    // El servidor procesará esto, decidirá qué hacer a continuación
                    // (siguiente pregunta o fin del juego) y lo notificará a todos.
                    this.socket.emit('game:timeExpired', {
                        gamePin: this.gamePin,
                        playerId: this.player.id,
                        questionId: this.currentQuestion ? this.currentQuestion.id : null // ID de la pregunta actual
                    });
                }
            }

            startTimer() {
                this.stopTimer(); // Asegurarse de que no haya múltiples intervalos corriendo
                this.timerInterval = setInterval(this.updateTimer.bind(this), 1000);
            }

            stopTimer() {
                clearInterval(this.timerInterval);
                this.timerInterval = null;
            }

            // MODIFICADO: generateQuestion ahora simplemente espera la pregunta del servidor
            // Esta función ya no genera la pregunta en el cliente.
            generateQuestion() {
                console.warn("generateQuestion() en el cliente no debe generar preguntas. Deben venir del servidor.");
                // Las preguntas se recibirán a través del evento 'newQuestion' de Socket.IO
            }

            displayQuestion(questionData) {
                this.currentQuestionDisplay.textContent = questionData.text;
                this.playerAnswerInput.value = ''; // Limpiar respuesta anterior
                this.playerAnswerInput.disabled = false;
                this.submitAnswerBtn.disabled = false;
            }

            // MODIFICADO: checkAnswer ahora solo envía la respuesta al servidor
            checkAnswer(respuesta) {
                // Deshabilitar la entrada y el botón inmediatamente para evitar múltiples envíos
                this.playerAnswerInput.disabled = true;
                this.submitAnswerBtn.disabled = true;

                // Envía la respuesta al servidor para su verificación
                this.socket.emit('player:submitAnswer', {
                    gamePin: this.gamePin,
                    playerId: this.player.id,
                    questionId: this.currentQuestion.id, // Asegúrate de que currentQuestion tenga un ID
                    answer: respuesta
                });
                this.showNotification('Respuesta enviada...', 'info');
                // El servidor responderá con 'questionResult' para dar feedback
            }

            displayResult(message, isCorrect) {
                this.answerResultDisplay.textContent = message;
                this.answerResultDisplay.classList.remove('tada', 'shake'); // Limpiar animaciones anteriores
                this.answerResultDisplay.classList.add(isCorrect ? 'tada' : 'shake');
            }

            updateProgressBar() {
                const progressPercentage = (this.questionCount / this.totalQuestions) * 100;
                this.progressBar.style.width = `${progressPercentage}%`;
                this.questionCountDisplay.textContent = `Pregunta: ${this.questionCount}/${this.totalQuestions}`;
            }

            updateLiveRanking(players) {
                this.rankingList.innerHTML = ''; // Limpiar la lista antes de añadir los nuevos items

                // Asegúrate de que los jugadores vengan ordenados por score desde el servidor
                // players.sort((a, b) => b.score - a.score); // Si no vienen ordenados, ordena aquí

                players.forEach(player => {
                    const rankingItem = document.createElement('li');
                    rankingItem.className = 'ranking-item';
                    rankingItem.innerHTML = `
                        <img src="${player.avatar}" alt="Avatar" class="ranking-avatar">
                        <span class="ranking-name">${player.name}</span>
                        <span class="ranking-score">${player.score} puntos</span>
                    `;
                    this.rankingList.appendChild(rankingItem);
                });
            }

            updateLobbyPlayers(players) {
                this.otherPlayersList.innerHTML = '';
                players.forEach(p => {
                    const playerItem = document.createElement('li');
                    playerItem.innerHTML = `
                        <img src="${p.avatar}" alt="Avatar" class="player-avatar">
                        <span class="player-name">${p.name}</span>
                        <span class="player-grade">${p.grade}</span>
                    `;
                    this.otherPlayersList.appendChild(playerItem);
                });
            }

            // NUEVO: Método para actualizar los conteos de votos en la UI
            updateModeVoteCounts() {
                this.modeItems.forEach(item => {
                    const mode = item.dataset.mode;
                    const countSpan = item.querySelector('.mode-vote-count');
                    if (countSpan) {
                        countSpan.textContent = this.modeVotes[mode] || 0;
                    }
                    // Visualmente desmarcar todos y luego marcar solo si el jugador actual votó por él
                    item.classList.remove('selected');
                    if (this.player.votedForMode === mode) {
                        item.classList.add('selected');
                    }
                });
            }

            // NUEVO: Método para actualizar los votos de los jugadores en el lobby
            updatePlayerVotesInLobby(players) {
                // Esto es más complejo. Si quieres mostrar qué votó cada jugador,
                // necesitarías ajustar tu .player-list li para incluir esa información
                // que el servidor debería enviar. Por ahora, solo actualiza la lista de jugadores.
                this.updateLobbyPlayers(players); // Re-renderiza la lista de jugadores.
                // Si cada jugador en 'players' tiene una propiedad 'votedForMode',
                // podrías iterar y actualizar visualmente.
            }

            displayFinalResults(finalRanking) {
                this.finalRankingList.innerHTML = '';
                finalRanking.forEach(player => {
                    const rankingItem = document.createElement('li');
                    rankingItem.className = 'ranking-item'; // Reutilizamos el estilo
                    rankingItem.innerHTML = `
                        <img src="${player.avatar}" alt="Avatar" class="ranking-avatar">
                        <span class="ranking-name">${player.name}</span>
                        <span class="ranking-score">${player.score} puntos</span>
                    `;
                    this.finalRankingList.appendChild(rankingItem);
                });
            }

            // NUEVO: Método para resetear el estado del lobby (votos, etc.)
            resetLobbyState() {
                console.log('Reiniciando estado del lobby en el cliente...');
                // Limpiar los votos en la interfaz de usuario
                document.querySelectorAll('.mode-vote-count').forEach(span => span.textContent = '0');
                document.querySelectorAll('.mode-item').forEach(item => item.classList.remove('selected')); // Desmarcar visualmente

                // Resetear el estado interno de los votos
                for (const mode in this.modeVotes) {
                    this.modeVotes[mode] = 0;
                }
                this.player.votedForMode = null; // Reiniciar el voto del jugador actual
                
                // Asegurarse de que los botones de votación estén habilitados
                this.modeItems.forEach(item => item.style.pointerEvents = 'auto');
                
                this.playerScore = 0; // Reiniciar puntuación local
                this.questionCount = 0; // Reiniciar contador de preguntas
                this.gameStarted = false; // Asegurar que el juego no está activo
                this.stopTimer(); // Detener cualquier temporizador residual

                // Limpiar displays de juego
                this.playerAnswerInput.value = '';
                this.answerResultDisplay.textContent = '';
                this.timerText.textContent = 30; // Resetear display del temporizador
                this.timerCircle.style.strokeDashoffset = 0; // Resetear círculo del temporizador
                this.timerCircle.style.stroke = 'var(--tiempo-normal)'; // Resetear color del temporizador
                this.playerScoreDisplay.textContent = 'Puntos: 0';
                this.questionCountDisplay.textContent = 'Pregunta: 0/10';
                this.progressBar.style.width = '0%';
                this.rankingList.innerHTML = ''; // Limpiar ranking en vivo
                this.finalRankingList.innerHTML = ''; // Limpiar ranking final
                
                // Asegurarse de que el botón de inicio de partida se muestre solo si es host
                if (this.startGameBtn) {
                    this.startGameBtn.style.display = this.isHost ? 'block' : 'none';
                }
            }


            // --- Utilidades ---
            showNotification(message, type = 'info', duration = 3000) {
                const notification = document.createElement('div');
                notification.classList.add('notification', type);
                let icon = '';
                if (type === 'success') icon = '<i class="fas fa-check-circle"></i>';
                else if (type === 'error') icon = '<i class="fas fa-times-circle"></i>';
                else if (type === 'info') icon = '<i class="fas fa-info-circle"></i>';

                notification.innerHTML = `${icon} <span>${message}</span>`;
                this.notificationContainer.appendChild(notification);

                setTimeout(() => {
                    notification.classList.add('hide');
                    notification.addEventListener('transitionend', () => notification.remove());
                }, duration);
            }

            handleNetworkError(error, message = "Error de red") {
                console.error(message, error);
                this.showNotification(`${message}. Intentando reconectar...`, 'error');
            }

            generateId() {
                return Math.random().toString(36).substr(2, 9);
            }

            playSound(soundId) {
                if (!this.soundEnabled) return;
                try {
                    const sound = document.getElementById(soundId);
                    if (sound) {
                        sound.currentTime = 0;
                        sound.play().catch(e => console.log("Error al reproducir sonido:", e));
                    }
                } catch (error) {
                    console.error("Error con el sonido:", error);
                }
            }

            loadSettings() {
                const soundEnabled = localStorage.getItem('soundEnabled');
                if (soundEnabled !== null) {
                    this.soundEnabled = soundEnabled === 'true';
                }
                this.toggleSoundBtn.classList.toggle('active', this.soundEnabled);
                this.toggleSoundBtn.querySelector('i').className = this.soundEnabled ? 'fas fa-volume-up' : 'fas fa-volume-mute';

                const darkModeEnabled = localStorage.getItem('darkModeEnabled');
                if (darkModeEnabled !== null) {
                    document.body.classList.toggle('dark-mode', darkModeEnabled === 'true');
                }
                const isDarkMode = document.body.classList.contains('dark-mode');
                this.toggleDarkModeBtn.classList.toggle('active', isDarkMode);
                this.toggleDarkModeBtn.querySelector('i').className = isDarkMode ? 'fas fa-sun' : 'fas fa-moon';
            }
        }

        // Inicialización del juego
        document.addEventListener('DOMContentLoaded', () => {
            try {
                const game = new GameManager();
                game.initGame(); // Iniciar la lógica del juego
                // Hacer accesible para depuración (opcional)
                window.game = game;
            } catch (error) {
                console.error("Error al iniciar el juego:", error);
                alert("Ocurrió un error al cargar el juego. Por favor recarga la página.");
            }
        });
    </script>
</body>
</html>
